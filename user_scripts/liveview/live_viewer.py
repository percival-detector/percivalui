#!/usr/bin/env python3
"""Live viewer for Percival

This utility displays images generated by the live view plugin of odin-data.

based on an original by
Tim Nicholls, STFC Application Engineering Group.
"""
import sys
import os
import random
import zmq
import signal
import argparse
import h5py
import time

from PyQt5 import QtCore, QtWidgets
import numpy as np

from mplplot import MplPlotCanvas, MplNavigationToolbar
from framestatsbar import FrameStatisticsBar

from descrambler import descramble_to_gn_crs_fn, aggregate_to_GnCrsFn


class LiveViewerDefaults(object):
    """
    Default parameters for the live viewer.

    This class implements a simple container of default parameters used
    for the live viewer.
    """

    def __init__(self):
        """Initialise default parameters."""
        self.endpoint_url = "tcp://127.0.0.1:5020"

        self.left = 10
        self.top = 10
        self.width = 600
        self.height = 500
        self.title = 'Percival Live View'
        self.cadu_min = None;
        self.cadu_max = None;

class LiveViewReceiver():
    """
    ZeroMQ-based receiver class for the live viewer.

    This class implements the ZeroMQ channel receiver for the live viewer. Receiving
    frames is socket event-driven to allow integration with the QT notifier 
    mechanism.
    """

    def __init__(self, endpoint_url):
        """Initialise the receiver."""
        # Create a ZeroMQ context, socket and connect the specified endpoint
        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.SUB)
        self.socket.setsockopt_string(zmq.SUBSCRIBE, "")
        self.socket.connect(endpoint_url)

        # Set up socket operation parameters
        self.zmq_flags = 0
        self.zmq_copy = True
        self.zmq_track = False
        self.reset_frame = None
        self.reset_frame_num = -1

        self.debug_socket = False

        # Initialise the frames received counter
        self.frames_received = 0

    def receive_frame(self):
        """
        Receive frames from the ZeroMQ channel.

        This method receives all the frames waiting in the ZeroMQ channel, clearing the channel to empty.
        It returns the latest data / reset frame or both if possible. We would like to return only one
        frame per call, but the reset and data frame can be published nearly simultaneously, so we need
        to be able to receive both of them in one call.
        Frames are here dropped when the viewer is unable to display them at the rated transmitted.
        """

        # Set up default header and frame data variables
        header = {}
        data = reset = None

        # Get the socket event flags 
        flags = self.socket.getsockopt(zmq.EVENTS)

        # Keep handling socket events until all flags are cleared. This is necessary as the
        # QT socket notifier is triggered on the state leaving non-empty so the socket must be
        # cleared of messages before returning.
        while flags != 0:

            if flags & zmq.POLLIN:

                # Receive the live view header first
                header = self.socket.recv_json(flags=self.zmq_flags)
                if self.debug_socket:
                    print("[Socket] received header: " + repr(header))

                if header['dtype'] == 'unknown':
                    header['dtype'] = 'uint16'

                # Receive the image data payload and convert into a numpy array
                # with the appropriate shape
                msg = self.socket.recv(
                    flags=self.zmq_flags, copy=self.zmq_copy, track=self.zmq_track)
                buf = memoryview(msg)
                array = np.frombuffer(buf, dtype=header['dtype'])
                frame_data =  array.reshape([int(header["shape"][0]), int(header["shape"][1])])

                if self.debug_socket:
                    print("[Socket] received frame dataset:", header['dataset'], "frame_num:", header['frame_num'],"shape: " + repr(frame_data.shape))

                if header['dataset'] == "data":
                  data = frame_data
                if header['dataset'] == "reset":
                  self.reset_frame = frame_data
                  self.reset_frame_num = header['frame_num']
                
                self.frames_received += 1

            elif flags & zmq.POLLOUT:
                if self.debug_socket:
                    print("[Socket] zmq.POLLOUT")
            elif flags & zmq.POLLERR:
                if self.debug_socket:
                    print("[Socket] zmq.POLLERR")
            else:
                if self.debug_socket:
                    print("[Socket] FAILURE")

            # Update socket event flags to drive loop
            flags = self.socket.getsockopt(zmq.EVENTS)
            if self.debug_socket:
                print("Flags at end", flags)

        if(data is not None):
          reset = self.reset_frame
          self.reset_frame = None
          if reset is not None and header['frame_num'] != self.reset_frame_num:
            print("ERROR: reset frame number mismatch:%d vs %d"%(self.reset_frame_num, header['frame_num']))
            reset = None

        return (reset, data)

    def get_socket_fd(self):
        """Return the ZeroMQ channel socket file descriptor."""
        return self.socket.getsockopt(zmq.FD)

    def reset_statistics(self):
        """Reset frames received statistics."""
        self.frames_received = 0


class LiveViewer(QtWidgets.QMainWindow):
    """
    Live viewer class.

    The class implements the main logic of the live viewer application and the associated
    user interface.
    """

    def __init__(self, args):
        """
        Initialise the live view.

        This method initialises the liew viewer application and user interface
        """
        super().__init__()
        
        self._calibfile = None
        # Create a default parameter object and parse command-line arguments
        self.defaults = LiveViewerDefaults()
        self.args = self._parse_arguments(args)

        # load optional calibfile
        if self.args.calibfile:
          self.load_calibfile(self.args.calibfile)

        if self.args.cadu_min is not None:
          self.cadu_min = self.args.cadu_min;
          print("cadu min set to", self.cadu_min);
        else:
          self.cadu_min = self.defaults.cadu_min;

        if self.args.cadu_max is not None:
          self.cadu_max = self.args.cadu_max;
          print("cadu max set to", self.cadu_max);
        else:
          self.cadu_max = self.defaults.cadu_max;

        # if the user wants to use a calibfile, we must specify it.
        self.descramble = self.args.descramble

        # Initialise frames shown counter        
        self.frames_shown = 0

        # Initialise the main window user interface after loading calibfile
        self.init_ui()

        # Create the receiver object
        self.receiver = LiveViewReceiver(self.args.endpoint_url)

        # Create a socket event notifier attached to the receiver socket and connect
        # to the receive handler
        # the notifier is a quirky thing and activates when it connects or disconnects
        # to the publisher, or when its incoming queue goes non-empty. I would be
        # inclined to do this ourselves in a background thread in the next version.
        self.notifier = QtCore.QSocketNotifier(
            self.receiver.get_socket_fd(), QtCore.QSocketNotifier.Read, self
        )
        self.notifier.activated.connect(self.handle_receive)

    def _parse_arguments(self, args=None):
        """
        Parse command line arguments.

        Parse command line arugments, using the default parameter object to set default
        values.
        """

        # First argument passed after QApplication processes sys.argv is the 
        # progam name
        prog_name=args.pop(0)

        # Set the terminal width for argument help formatting
        try:
            term_columns = int(os.environ['COLUMNS']) - 2
        except (KeyError, ValueError):
            term_columns = 100

        # Build options for the argument parser
        parser = argparse.ArgumentParser(
            prog=prog_name, description='Percival live viewer',
            formatter_class=lambda prog: argparse.ArgumentDefaultsHelpFormatter(
                prog, max_help_position=40, width=term_columns)
        )

        parser.add_argument('--endpoint', type=str, dest="endpoint_url",
                            default=self.defaults.endpoint_url,
                            help='ZeroMQ endpoint URL to connect to')

        parser.add_argument('--descramble', default=False, dest="descramble", action="store_true",
                            help='Employ software descrambling')

        parser.add_argument('--calibfile', default=None, dest="calibfile",
                            help='h5 file containing calibration constants')

        parser.add_argument('--cadu_min', default=None, type=float,
                            help='min value for combined-adu graphs')

        parser.add_argument('--cadu_max', default=None, type=float,
                            help='max value for combined-adu graphs')



        # Parse and return arguments
        parsed_args = parser.parse_args(args)
        return parsed_args

    def load_calibfile(self, filepath):
        if os.path.isfile(filepath):
          try:
            self._calibfile = h5py.File(filepath);
            self._Sc = np.asarray(self._calibfile["sample/coarse/slope"]);
            self._Oc = np.asarray(self._calibfile["sample/coarse/offset"]);
            self._Sf = np.asarray(self._calibfile["sample/fine/slope"]);
            self._Of = np.asarray(self._calibfile["sample/fine/offset"]);

            if(self._Sc.shape[1] == 1440):
              print("Removing reference column from calibration datasets");
              self._Sc = self._Sc[:,32:];
              self._Oc = self._Oc[:,32:];
              self._Sf = self._Sf[:,32:];
              self._Of = self._Of[:,32:];
          except:
            print("ERROR could not load requisite datasets from", filepath);
            self._calibfile = None;
            exit(1);
          else:
            print("loaded calibfile ok", filepath);
            self._calibfile.close();
            self._calibfile = True;
        else:
          print("ERROR could not find", filepath);
          exit(1);

    def init_ui(self):
        """
        Initialise the user interface.

        This method initialises the QT main window interface, setting up the various widgets
        and showing the window.
        """
        # Set window title and geometry
        self.setWindowTitle(self.defaults.title)
        self.setGeometry(
            self.defaults.left, self.defaults.top, self.defaults.width, self.defaults.height)

        # Create a main widget as a canvas to place other things onto
        self.main_widget = QtWidgets.QWidget(self)

        # Create a vertical box layout
        vbl = QtWidgets.QVBoxLayout(self.main_widget)

        # Instantiate a Matplotlib canvas
        if(self._calibfile):
          self.plot = MplPlotCanvas(self.main_widget, labels = ('ResetCADU', 'SampleCADU', 'Difference'))
        else:
          self.plot = MplPlotCanvas(self.main_widget)

        # Instantiate the navigation toolbar for the plot
        self.nav_tool_bar = MplNavigationToolbar(self.plot, self.main_widget)

        # Instantiate and configure the frame statistics bar
        self.stats_bar = FrameStatisticsBar(self.main_widget)
        self.stats_bar.connect_reset(self.on_reset_stats)

        # Pack widgets into the vertical box layout
        vbl.addWidget(self.nav_tool_bar)
        vbl.addWidget(self.plot)
        vbl.addWidget(self.stats_bar)
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.setSpacing(0)

        # Set focus on the main widget
        self.main_widget.setFocus()

        # Set the central widget of the main window to main_widget
        self.setCentralWidget(self.main_widget)
 
        # Show the window
        self.show()

    def nan2zero(self, img):
        """
        apply_calib is expected to have some NaN pixels as NaN is used as a signifier for
        a dead pixel or something. These NaN values confuse the auto-scaling algorithm so
        we can set them all to zero.
        """
        if img is not None:
          nanidx = np.isnan(img);
          img[nanidx] = 0.0;
        return img;

    def apply_calib(self, resetGCF, dataGCF):
        """
        This applies the calib coefficients to data, reset frames and performs CDS on the two.
        The function can accept None in its arguments, in which case None is returned.
        @return a triple of frames (resetCADU, dataCADU, diffCADU) all with the same units.
        """
        dataCADU = resetCADU = diffCADU = None;

        # check on the dimensions of the calibfile or the broadcast will fail
        if(dataGCF is not None):
          if(dataGCF[0].shape != self._Sc.shape):
            print("ERROR the dimensions of the calibfile is", self._Sc.shape, "and the dims of the dataframe is", dataGCF[0].shape);
            return (resetCADU, dataCADU, diffCADU);

        idOf = 128.0*32;
        idSl = idOf / 1.5;

        if(dataGCF is not None):
          dataCADU = idOf + (idSl / self._Sc) * (dataGCF[1] + 1.0 - self._Oc) - (idSl / self._Sf) * (dataGCF[2] - self._Of);
          g0idx = (dataGCF[0] == 0);
        if(resetGCF is not None):
          resetCADU = idOf + (idSl / self._Sc) * (resetGCF[1] + 1.0 - self._Oc) - (idSl / self._Sf) * (resetGCF[2] - self._Of);

        if(dataCADU is not None and resetCADU is not None):
          diffCADU = dataCADU.copy();
          # this idiomatic statement subtracts the reset entry where g0idx is True
          diffCADU[g0idx] -= resetCADU[g0idx];

        return (resetCADU, dataCADU, diffCADU);

    def handle_receive(self):
        """
        Handle receive events.

        This method handles receive events generated by the socket notifier, 
        calling the receiver and rendering any frames returned.
        """

        dataGCF = resetGCF = None
        diffCADC = dataCADC = resetCADC = None

        # Get frame data from the receiver
        (resetf, dataf) = self.receiver.receive_frame()

        # Plot frame data if returned
        if dataf is not None:
          if self.descramble:
            dataGCF = descramble_to_gn_crs_fn(dataf,
                                              False, # refColH1_0_Flag
                                              True,  # cleanmem
                                              False) # verbose
          else:
            dataGCF = aggregate_to_GnCrsFn(dataf)

          if resetf is not None:
            if self.descramble:
              resetGCF = descramble_to_gn_crs_fn(resetf,
                                                False, # refColH1_0_Flag
                                                True,  # cleanmem
                                                False) # verbose
            else:
              resetGCF = aggregate_to_GnCrsFn(resetf)

          if self._calibfile:
            (resetCADU, dataCADU, diffCADU) = self.apply_calib(resetGCF, dataGCF)
            self.nan2zero(resetCADU); self.nan2zero(dataCADU); self.nan2zero(diffCADU)
            self.plot.multi_render_frame((resetCADU, dataCADU, diffCADU), self.cadu_min, self.cadu_max)
          else:
            self.plot.multi_render_frame((dataGCF[0], dataGCF[1], dataGCF[2]))

          self.frames_shown += 1

          # Update statistics bar
          self.stats_bar.update(self.receiver.frames_received, self.frames_shown)


    @QtCore.pyqtSlot()
    def on_reset_stats(self):
        """
        Reset the frame statistics displayed in the view viewer.
        
        This method implements a slot called to reset the viewer frame statistics
        when the reset button is pressed.
        """
        
        # Reset frames stats in this object and in receiver
        self.receiver.reset_statistics()
        self.frames_shown = 0

        # Update the stastics bar widget
        self.stats_bar.update(self.receiver.frames_received, self.frames_shown)


def main():
    """Main application entry point."""

    # Bind Ctrl-C INT signal to default to make work in the app GUI
    signal.signal(signal.SIGINT, signal.SIG_DFL)

    # Construct QT app and viewer objects
    app = QtWidgets.QApplication(sys.argv)
    # app.arguments is the same as sys.argv
    live_viewer = LiveViewer(app.arguments())

    # Run the app to completion
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()
